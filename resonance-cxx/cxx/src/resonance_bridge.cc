#include "resonance_bridge.h"
#include "rust/cxx.h"
// Include the authoritative resonance audio header here so the implementation
// can use the concrete vraudio::ResonanceAudioApi definitions.
#include <resonance_audio_api.h>
// Include the cxx-generated header for the bridge (crate-prefixed path).
#include "resonance-cxx/src/bridge.rs.h" // Generated by cxx for enums/structs

#include <cstdio>
#include <utility>

namespace ra {

Api::~Api() = default;

Api::Api(std::unique_ptr<vraudio::ResonanceAudioApi> impl) : impl_(std::move(impl)) {}


static inline bool check_size(std::size_t channels, std::size_t frames, std::size_t len) {
  const std::size_t need = channels * frames;
  if (len != need) {
    std::fprintf(stderr, "[resonance-cxx] buffer size mismatch: have=%zu need=%zu (ch=%zu, frames=%zu)\n", len, need, channels, frames);
    return false;
  }
  return true;
}

std::unique_ptr<Api> make_api(std::size_t num_channels, std::size_t frames_per_buffer, int sample_rate_hz) {
  vraudio::ResonanceAudioApi* raw = vraudio::CreateResonanceAudioApi(num_channels, frames_per_buffer, sample_rate_hz);
  if (!raw) {
    std::fprintf(stderr, "[resonance-cxx] CreateResonanceAudioApi returned null\n");
    return nullptr;
  }
  // Take ownership of raw pointer returned by the C factory.
  return std::make_unique<Api>(std::unique_ptr<vraudio::ResonanceAudioApi>(raw));
}

// Member method implementations forwarding to impl_
bool Api::fill_interleaved_f32(std::size_t num_channels, std::size_t num_frames, rust::Slice<float> buffer) {
  if (!check_size(num_channels, num_frames, buffer.size())) return false;
  return impl_->FillInterleavedOutputBuffer(num_channels, num_frames, buffer.data());
}

bool Api::fill_interleaved_i16(std::size_t num_channels, std::size_t num_frames, rust::Slice<int16_t> buffer) {
  if (!check_size(num_channels, num_frames, buffer.size())) return false;
  return impl_->FillInterleavedOutputBuffer(num_channels, num_frames, buffer.data());
}

void Api::set_head_position(float x, float y, float z) { impl_->SetHeadPosition(x, y, z); }
void Api::set_head_rotation(float x, float y, float z, float w) { impl_->SetHeadRotation(x, y, z, w); }
void Api::set_master_volume(float volume) { impl_->SetMasterVolume(volume); }
void Api::set_stereo_speaker_mode(bool enabled) { impl_->SetStereoSpeakerMode(enabled); }

int Api::create_ambisonic_source(std::size_t num_channels) { return impl_->CreateAmbisonicSource(num_channels); }
int Api::create_stereo_source(std::size_t num_channels) { return impl_->CreateStereoSource(num_channels); }
int Api::create_sound_object_source(ra::RenderingMode mode) { return impl_->CreateSoundObjectSource(static_cast<vraudio::RenderingMode>(mode)); }
void Api::destroy_source(int source_id) { impl_->DestroySource(source_id); }

void Api::set_interleaved_buffer_f32(int source_id, rust::Slice<const float> audio, std::size_t num_channels, std::size_t num_frames) {
  if (!check_size(num_channels, num_frames, audio.size())) return;
  impl_->SetInterleavedBuffer(source_id, audio.data(), num_channels, num_frames);
}
void Api::set_interleaved_buffer_i16(int source_id, rust::Slice<const int16_t> audio, std::size_t num_channels, std::size_t num_frames) {
  if (!check_size(num_channels, num_frames, audio.size())) return;
  impl_->SetInterleavedBuffer(source_id, audio.data(), num_channels, num_frames);
}

void Api::set_source_distance_attenuation(int source_id, float distance_attenuation) { impl_->SetSourceDistanceAttenuation(source_id, distance_attenuation); }
void Api::set_source_distance_model(int source_id, ra::DistanceRolloffModel rolloff, float min_distance, float max_distance) { impl_->SetSourceDistanceModel(source_id, static_cast<vraudio::DistanceRolloffModel>(rolloff), min_distance, max_distance); }
void Api::set_source_position(int source_id, float x, float y, float z) { impl_->SetSourcePosition(source_id, x, y, z); }
void Api::set_source_room_effects_gain(int source_id, float room_effects_gain) { impl_->SetSourceRoomEffectsGain(source_id, room_effects_gain); }
void Api::set_source_rotation(int source_id, float x, float y, float z, float w) { impl_->SetSourceRotation(source_id, x, y, z, w); }
void Api::set_source_volume(int source_id, float volume) { impl_->SetSourceVolume(source_id, volume); }
void Api::set_sound_object_directivity(int source_id, float alpha, float order) { impl_->SetSoundObjectDirectivity(source_id, alpha, order); }
void Api::set_sound_object_listener_directivity(int source_id, float alpha, float order) { impl_->SetSoundObjectListenerDirectivity(source_id, alpha, order); }
void Api::set_sound_object_near_field_effect_gain(int source_id, float gain) { impl_->SetSoundObjectNearFieldEffectGain(source_id, gain); }
void Api::set_sound_object_occlusion_intensity(int source_id, float intensity) { impl_->SetSoundObjectOcclusionIntensity(source_id, intensity); }
void Api::set_sound_object_spread(int source_id, float spread_deg) { impl_->SetSoundObjectSpread(source_id, spread_deg); }

void Api::enable_room_effects(bool enable) { impl_->EnableRoomEffects(enable); }
void Api::set_reflection_properties(const ra::ReflectionProperties& p) {
  vraudio::ReflectionProperties rp;
  rp.room_position[0] = p.room_position[0];
  rp.room_position[1] = p.room_position[1];
  rp.room_position[2] = p.room_position[2];
  rp.room_rotation[0] = p.room_rotation[0];
  rp.room_rotation[1] = p.room_rotation[1];
  rp.room_rotation[2] = p.room_rotation[2];
  rp.room_rotation[3] = p.room_rotation[3];
  rp.room_dimensions[0] = p.room_dimensions[0];
  rp.room_dimensions[1] = p.room_dimensions[1];
  rp.room_dimensions[2] = p.room_dimensions[2];
  rp.cutoff_frequency = p.cutoff_frequency;
  for (int i = 0; i < 6; ++i) rp.coefficients[i] = p.coefficients[ i ];
  rp.gain = p.gain;
  impl_->SetReflectionProperties(rp);
}

void Api::set_reverb_properties(const ra::ReverbProperties& p) {
  vraudio::ReverbProperties rp;
  for (int i = 0; i < 9; ++i) rp.rt60_values[i] = p.rt60_values[i];
  rp.gain = p.gain;
  impl_->SetReverbProperties(rp);
}

} // namespace ra
