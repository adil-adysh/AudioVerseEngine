# Project TODOs â€” audio-engine priorities

This file is an automated snapshot (generated by an assistant) mapping the `docs/audio-game-engine.md` design to the repository and listing prioritized, actionable todos.

Summary of findings
- Implemented / present:
  - Asset manager and SFX support: `asset-manager/src/sfx.rs`, `asset-manager/src/loader.rs`, `asset-manager/src/asset_pkg.rs` provide `.sfx` parsing, loader cache, and package handling.
  - Resonance Audio bridge: `resonance-cxx/src/bridge.rs` and related C++ glue exist and are wired into the workspace (`resonance-cxx/cxx/**`).
  - Resonance integration helpers: `resonance-audio-engine/src/spatializer.rs` and a renderer bridge use the `resonance-cxx` API.
  - Physics tooling: `rapier/` crate contains collision event types and physics primitives (used as a physics library integration).
  - Engine core crate placeholder: `engine-core/engine-core/src/lib.rs` exists (minimal example/tests present).

- Partially implemented / needs work:
  - Game ECS / Scene / System infrastructure: crate `engine-core` exists but lacks a full, documented ECS Scene/Prefab implementation matching the design doc.
  - EventBus: design is documented but no central, engine-wide `EventBus` implementation found in core crates (some event types exist in `rapier`).
  - AudioSystem: resonant audio bridge exists, but a high-level `AudioSystem` (that listens to events, manages AudioSourceComponents, and integrates with Scene/Entity data) is not found.
  - Environment & Rooms: `Room` and `AcousticProfile` concepts are documented but no concrete crate-level implementation found.

- Missing / not-started:
  - Player & Input wiring (InputComponent, Player entity) to trigger audio events.
  - Prefab format parsing and scene instantiation pipeline.
  - Event-driven collision-to-audio flow glue (Physics -> EventBus -> AudioSystem).
  - High-level tests and CI jobs that build native resonance code and validate the cxx bridge end-to-end.

Prioritized actionable todos

1. Core EventBus (owner: core, effort: small)
   - Add a lightweight, thread-safe `EventBus` in `engine-core` (publish/subscribe, typed events or string+payload). Provide a small unit test.
   - Acceptance: `engine-core` has `event_bus.rs` and tests exercising publish/subscribe.

2. Scene / ECS scaffolding (owner: core, effort: medium)
   - Expand `engine-core` with `Scene`, `Entity`, `Component` primitives and a `System` trait. Implement a minimal `GameLoop` runner.
   - Acceptance: example that creates a Scene, registers a System, and advances one frame.

3. AudioSystem facade (owner: audio, effort: medium)
   - Implement `AudioSystem` that subscribes to `CollisionEvent` and `GameplayEvent` on the `EventBus`, resolves `AudioAsset` via `asset-manager`, and drives `resonance-cxx` via `resonance-audio-engine` spatializer/renderer.
   - Provide a smoke test that loads an `.sfx` from `assets/dest/out.pkg` and plays (or calls into the spatializer) for one frame.

4. Physics -> Event integration (owner: physics, effort: small)
   - Add a small glue layer that listens to `rapier` collision events and publishes `CollisionEvent` into the `EventBus` with entity IDs and contact point.

5. Rooms & Environment (owner: audio, effort: small)
   - Implement `Room` and `AcousticProfile` types and a spatial query helper in `resonance-audio-engine` or `engine-core` to resolve the listener's room.

6. Prefabs & SceneDefinition loader (owner: tools, effort: medium)
   - Implement `SceneDefinition` parsing and prefab instantiation using `asset-manager` for asset refs.

7. CI: native build + cxx bridge check (owner: infra, effort: medium)
   - Add CI job that builds `resonance-audio` native lib (CMake or placeholder), then runs `cargo build` across the workspace to validate the cxx bridge.

Low-risk immediate wins
- Add a tiny `engine-core::event_bus` implementation (few hundred lines) and tests.
- Add integration test that constructs minimal Scene + Physics collision, publishes a `CollisionEvent` and asserts `AudioSystem` received it (mocked spatializer).

Notes and next steps
- If you'd like, I can implement the `event_bus` crate/module and a unit test now (small, self-contained change) to unblock other work. Say "implement event bus" and I'll proceed.
# Audio Game Engine TODOs

## Easy/Foundational Tasks
1. Set up Rust workspace and crate structure (`audio-backend`, `resonance-ffi`, `resonance`, `engine-core`, `content-pipeline`, `app-android`, `app-windows`).
2. Implement `resonance-ffi`: raw externs for ResonanceAudioApi FFI surface.
3. Create safe wrapper `ResonanceCtx` for FFI in Rust.
4. Implement `audio-backend` trait and basic CPAL (Windows) backend.
5. Implement lock-free command queue and frame scheduler (single-producer, single-consumer).

6. Implement basic source registry and ring buffer logic.
7. Implement minimal Engine API: init, shutdown, create/destroy source, play clip, set listener pose.
8. Implement simple ECS setup with `hecs` (entities, components for audio sources/listener).
9. Implement basic content loader for RON/JSON assets.

## Intermediate Tasks
10. Implement Oboe (Android) backend and JNI wrapper.
11. Integrate ResonanceAudioApi for spatialization and room effects.
12. Implement room, occlusion, and sequencer ECS systems.
13. Implement streaming for long audio files (lock-free ring buffer per source).
14. Implement asset validation (sample rate, channel layout, loudness scan).
15. Implement telemetry: XRun detection, output meter, latency probes.
16. Implement dynamic range profiles and ducking logic.

## Advanced/Polish Tasks
17. Implement cross-platform build scripts (Windows launcher, Android AAR packaging).
18. Implement DOT dump of ECS and audio routing for diagnostics.
19. Implement adaptive buffer sizing and voice capping.
20. Implement limiter (optional) before render.
21. Implement loopback test harness for latency measurement.
22. Finalize documentation and minimal example code.

## Testing
23. Write unit tests for command ordering, scheduler, ring buffer, parameter smoothing.
24. Write DSP tests (null rendering, denormals, buffer wrap correctness).
25. Write performance tests (128+ sources, no XRuns).
26. Write room/transition tests (crossfade, property updates).

---

*Start with foundational tasks and progress to intermediate and advanced features. Prioritize easy-to-implement, core engine features first.*
